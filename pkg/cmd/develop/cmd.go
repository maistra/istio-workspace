package develop

import (
	"bytes"
	"fmt"
	"os"

	"emperror.dev/errors"
	gocmd "github.com/go-cmd/cmd"
	"github.com/go-logr/logr"
	"github.com/spf13/cobra"

	"github.com/maistra/istio-workspace/e2e/infra"
	"github.com/maistra/istio-workspace/pkg/cmd/config"
	"github.com/maistra/istio-workspace/pkg/cmd/execute"
	internal "github.com/maistra/istio-workspace/pkg/cmd/internal/session"
	"github.com/maistra/istio-workspace/pkg/log"
	"github.com/maistra/istio-workspace/pkg/shell"
	"github.com/maistra/istio-workspace/pkg/telepresence"
	"github.com/maistra/istio-workspace/test/scenarios"
)

var logger = func() logr.Logger {
	return log.Log.WithValues("type", "develop")
}

var errorTpNotAvailable = errors.Errorf("unable to find %s on your $PATH", telepresence.BinaryName)

// NewCmd creates instance of "develop" Cobra Command with flags and execution logic defined.
func NewCmd() *cobra.Command {
	developCmd := createDevelopCmd()

	newCmd := &cobra.Command{
		Use:         "new",
		Annotations: tpAnnotations,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			name := cmd.Flag("name").Value.String()
			e := cmd.Parent().PersistentFlags().Set("deployment", name+"-v1")

			return errors.Wrapf(e, "failed populating flags")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			// service-name (provided by --name flag or autogenerated?)
			// --type deployment|deploymentconfig
			var buf bytes.Buffer
			// this will get objects instead to call using k8s client
			name := cmd.Flag("name").Value.String()
			scenarios.BasicNewService(&buf, name, cmd.Flag("namespace").Value.String())
			// TMP
			infra.CreateFile("/tmp/new-service.yaml", buf.String())
			kubectl := gocmd.NewCmdOptions(shell.StreamOutput, "kubectl", "apply",
				"-n", cmd.Flag("namespace").Value.String(),
				"-f", "/tmp/new-service.yaml")
			shell.RedirectStreams(kubectl, cmd.OutOrStdout(), cmd.OutOrStderr())
			<-kubectl.Start()
			<-kubectl.Done()
			// TMP

			return errors.Wrapf(cmd.Parent().RunE(cmd, args), "failed executing parent `ike develop` command")
		},
	}
	newCmd.Flags().String("name", "", "defines service/deployment name")
	newCmd.Flags().String("type", "deployment", "deployment/deploymentconfig")

	developCmd.AddCommand(newCmd)

	return developCmd
}

var tpAnnotations = map[string]string{
	"telepresence": "translatable",
}

func createDevelopCmd() *cobra.Command {
	developCmd := &cobra.Command{
		Use:              "develop",
		Short:            "Starts the development flow",
		SilenceUsage:     true,
		TraverseChildren: true,
		Annotations:      tpAnnotations,
		PreRunE: func(cmd *cobra.Command, args []string) error {
			if !telepresence.BinaryAvailable() {
				return errorTpNotAvailable
			}

			return errors.Wrap(config.SyncFullyQualifiedFlags(cmd), "failed syncing flags")
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			dir, err := os.Getwd()
			if err != nil {
				return errors.Wrap(err, "failed obtaining working directory")
			}
			sessionState, _, sessionClose, err := internal.Sessions(cmd)
			if sessionClose != nil {
				defer sessionClose()
			}
			if err != nil {
				return errors.Wrap(err, "failed setting up session")
			}

			// HACK: need contract with TP cmd?
			if err = cmd.Flags().Set("deployment", sessionState.DeploymentName); err != nil {
				return errors.Wrapf(err, "failed to set deployment flag")
			}

			arguments, err := telepresence.CreateTpCommand(cmd)
			if err != nil {
				return errors.Wrap(err, "failed translating to telepresence command")
			}

			done := make(chan gocmd.Status, 1)
			defer close(done)

			go func() {
				tp := gocmd.NewCmdOptions(shell.StreamOutput, telepresence.BinaryName, arguments...)
				tp.Dir = dir
				shell.RedirectStreams(tp, cmd.OutOrStdout(), cmd.OutOrStderr())
				shell.ShutdownHookForChildCommand(tp)
				shell.Start(tp, done)
			}()

			if hint, err := Hint(&sessionState); err == nil {
				logger().Info(hint)
			}

			finalStatus := <-done

			return errors.WrapIf(finalStatus.Error, "failed executing sub command")
		},
	}

	if developCmd.Annotations == nil {
		developCmd.Annotations = map[string]string{}
	}
	developCmd.Annotations[internal.AnnotationRevert] = "true"

	developCmd.PersistentFlags().StringP("deployment", "d", "", "name of the deployment or deployment config")
	developCmd.PersistentFlags().StringSliceP("port", "p", []string{}, "list of ports to be exposed in format local[:remote].")
	developCmd.PersistentFlags().StringP(execute.RunFlagName, "r", "", "command to run your application")
	developCmd.PersistentFlags().StringP(execute.BuildFlagName, "b", "", "command to build your application before run")
	developCmd.PersistentFlags().Bool(execute.NoBuildFlagName, false, "always skips build")
	developCmd.PersistentFlags().Bool("watch", false, "enables watch")
	developCmd.PersistentFlags().StringSliceP("watch-include", "w", []string{"."}, "list of directories to watch (relative to the one from which ike has been started)")
	developCmd.PersistentFlags().StringSlice("watch-exclude", execute.DefaultExclusions, fmt.Sprintf("list of patterns to exclude (always excludes %v)", execute.DefaultExclusions))
	developCmd.PersistentFlags().Int64("watch-interval", 500, "watch interval (in ms)")
	if err := developCmd.PersistentFlags().MarkHidden("watch-interval"); err != nil {
		logger().Error(err, "failed while trying to hide a flag")
	}
	developCmd.PersistentFlags().Bool("offline", false, "avoid calling external sources")
	if err := developCmd.PersistentFlags().MarkHidden("offline"); err != nil {
		logger().Error(err, "failed while trying to hide a flag")
	}
	developCmd.PersistentFlags().StringP("method", "m", "inject-tcp", "telepresence proxying mode - see https://www.telepresence.io/reference/methods")
	developCmd.PersistentFlags().StringP("session", "s", "", "create or join an existing session")
	developCmd.PersistentFlags().StringP("route", "", "", "specifies traffic route options in the format of type:name=value. "+
		"Defaults to X-Workspace-Route header with current session name value")
	developCmd.PersistentFlags().StringP("namespace", "n", "", "target namespace to develop against "+
		"(defaults to default for the current context)")

	developCmd.Flags().VisitAll(config.BindFullyQualifiedFlag(developCmd))

	_ = developCmd.MarkPersistentFlagRequired("deployment")
	_ = developCmd.MarkPersistentFlagRequired(execute.RunFlagName)

	return developCmd
}
